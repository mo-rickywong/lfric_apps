!-----------------------------------------------------------------------------
! (c) Crown copyright 2024 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!> @brief Test the subgrid horizontal functions used for FFSL transport

module subgrid_horizontal_support_mod_test

  use constants_mod,                  only: i_def, l_def, r_tran
  use transport_enumerated_types_mod, only: horizontal_monotone_none,     &
                                            horizontal_monotone_strict,   &
                                            horizontal_monotone_relaxed,  &
                                            horizontal_monotone_positive, &
                                            horizontal_monotone_qm_pos

  implicit none

contains

  !------------------------------------------------------------------

  @test
  subroutine fourth_order_horizontal_edge_test()
    use pFUnit_Mod
    use, intrinsic :: iso_fortran_env,  only: real64
    use subgrid_horizontal_support_mod, only: fourth_order_horizontal_edge

    implicit none

    real(kind=r_tran)   :: rho(1:5), edge_left, edge_right, tol
    real(kind=r_tran)   :: answer_left, answer_right

    ! Set tolerance
    if ( r_tran == real64 ) then
      tol = 1.0e-12_r_tran
    else
      tol = 1.0e-6_r_tran
    end if

    ! Test a linear function
    rho(1) = 1.0_r_tran
    rho(2) = 3.0_r_tran
    rho(3) = 5.0_r_tran
    rho(4) = 7.0_r_tran
    rho(5) = 9.0_r_tran

    answer_left  = 4.0_r_tran
    answer_right = 6.0_r_tran

    call fourth_order_horizontal_edge(rho, edge_left, edge_right)
    @assertEqual(answer_left,  edge_left, tol)
    @assertEqual(answer_right, edge_right, tol)

    ! Test a non-linear function
    rho(1) = 0.0_r_tran
    rho(2) = 10.0_r_tran
    rho(3) = 9.0_r_tran
    rho(4) = 4.0_r_tran
    rho(5) = 6.0_r_tran

    answer_left  = 10.75_r_tran
    answer_right = 6.25_r_tran

    call fourth_order_horizontal_edge(rho, edge_left, edge_right)
    @assertEqual(answer_left,  edge_left, tol)
    @assertEqual(answer_right, edge_right, tol)

  end subroutine fourth_order_horizontal_edge_test

  !------------------------------------------------------------------

  @test
  subroutine nirvana_horizontal_edge_test()
    use pFUnit_Mod
    use, intrinsic :: iso_fortran_env,  only: real64
    use subgrid_horizontal_support_mod, only: nirvana_horizontal_edge

    implicit none

    real(kind=r_tran)   :: rho(1:3), edge_left, edge_right, tol
    real(kind=r_tran)   :: answer_left, answer_right

    ! Set tolerance
    if ( r_tran == real64 ) then
      tol = 1.0e-12_r_tran
    else
      tol = 1.0e-6_r_tran
    end if

    ! Test a linear function
    rho(1) = 1.0_r_tran
    rho(2) = 3.0_r_tran
    rho(3) = 5.0_r_tran

    answer_left  = 2.0_r_tran
    answer_right = 4.0_r_tran

    call nirvana_horizontal_edge(rho, edge_left, edge_right)
    @assertEqual(answer_left,  edge_left, tol)
    @assertEqual(answer_right, edge_right, tol)

    ! Test a non-linear function
    rho(1) = 1.0_r_tran
    rho(2) = 4.0_r_tran
    rho(3) = 10.0_r_tran

    answer_left  = 2.0_r_tran
    answer_right = 6.5_r_tran

    call nirvana_horizontal_edge(rho, edge_left, edge_right)
    @assertEqual(answer_left,  edge_left, tol)
    @assertEqual(answer_right, edge_right, tol)

  end subroutine nirvana_horizontal_edge_test

  !------------------------------------------------------------------

  @test
  subroutine monotonic_horizontal_edge_test()
    use pFUnit_Mod
    use, intrinsic :: iso_fortran_env,  only: real64
    use subgrid_horizontal_support_mod, only: monotonic_horizontal_edge

    implicit none

    real(kind=r_tran)   :: rho(1:3), edge_left, edge_right, tol
    real(kind=r_tran)   :: answer_left, answer_right, min_val
    integer(kind=i_def) :: monotone

    ! Set tolerance
    if ( r_tran == real64 ) then
      tol = 1.0e-12_r_tran
    else
      tol = 1.0e-6_r_tran
    end if

    ! Set field data
    rho(1) = 1.0_r_tran
    rho(2) = 2.0_r_tran
    rho(3) = 4.0_r_tran
    min_val = 0.0_r_tran

    ! Set edge values
    edge_left = -1.0_r_tran
    edge_right = 4.5_r_tran

    ! Test with no monotonicity (edge values should not change)
    monotone = horizontal_monotone_none
    answer_left  = -1.0_r_tran
    answer_right = 4.5_r_tran

    call monotonic_horizontal_edge(rho, monotone, min_val, edge_left, edge_right)
    @assertEqual(answer_left,  edge_left, tol)
    @assertEqual(answer_right, edge_right, tol)

    ! Reset edge values
    edge_left = -1.0_r_tran
    edge_right = 4.5_r_tran

    ! Test with strict monotonicity (edge values should be bounded)
    monotone = horizontal_monotone_strict
    answer_left  = 1.0_r_tran
    answer_right = 4.0_r_tran

    call monotonic_horizontal_edge(rho, monotone, min_val, edge_left, edge_right)
    @assertEqual(answer_left,  edge_left, tol)
    @assertEqual(answer_right, edge_right, tol)

    ! Reset edge values
    edge_left = -1.0_r_tran
    edge_right = 4.5_r_tran

    ! Test with relaxed monotonicity (edge values should be bounded)
    monotone = horizontal_monotone_relaxed
    answer_left  = 1.0_r_tran
    answer_right = 4.0_r_tran

    call monotonic_horizontal_edge(rho, monotone, min_val, edge_left, edge_right)
    @assertEqual(answer_left,  edge_left, tol)
    @assertEqual(answer_right, edge_right, tol)

    ! Reset edge values
    edge_left = -1.0_r_tran
    edge_right = 4.5_r_tran

    ! Test with positive monotonicity (edge values should be positive)
    monotone = horizontal_monotone_positive
    answer_left  = 0.0_r_tran
    answer_right = 4.5_r_tran

    call monotonic_horizontal_edge(rho, monotone, min_val, edge_left, edge_right)
    @assertEqual(answer_left,  edge_left, tol)
    @assertEqual(answer_right, edge_right, tol)

    ! Reset edge values
    edge_left = -1.0_r_tran
    edge_right = 4.5_r_tran

    ! Test with quasi-monotonicity (edge values should be bounded by min_val)
    monotone = horizontal_monotone_qm_pos
    answer_left  = 0.0_r_tran
    answer_right = 4.5_r_tran

    call monotonic_horizontal_edge(rho, monotone, min_val, edge_left, edge_right)
    @assertEqual(answer_left,  edge_left, tol)
    @assertEqual(answer_right, edge_right, tol)

  end subroutine monotonic_horizontal_edge_test

  !------------------------------------------------------------------

  @test
  subroutine subgrid_quadratic_recon_test()
    use pFUnit_Mod
    use, intrinsic :: iso_fortran_env,  only: real64
    use subgrid_horizontal_support_mod, only: subgrid_quadratic_recon

    implicit none

    real(kind=r_tran)   :: rho, edge_left, edge_right, tol
    real(kind=r_tran)   :: answer, recon, dep_pt
    integer(kind=i_def) :: monotone

    ! Set tolerance and switch monotonicity off
    if ( r_tran == real64 ) then
      tol = 1.0e-12_r_tran
    else
      tol = 1.0e-6_r_tran
    end if

    ! Set field data
    rho = 2.0_r_tran
    edge_left  = 4.0_r_tran
    edge_right = 6.0_r_tran

    ! Test positive departure distance with no monotonicity
    monotone = horizontal_monotone_none
    dep_pt = 0.2_r_tran
    answer = 4.24_r_tran

    call subgrid_quadratic_recon(recon, dep_pt, rho, edge_left, edge_right, monotone)
    @assertEqual(answer, recon, tol)

    ! Test positive departure distance with strict monotonicity
    monotone = horizontal_monotone_strict
    dep_pt = 0.2_r_tran
    answer = 2.0_r_tran

    call subgrid_quadratic_recon(recon, dep_pt, rho, edge_left, edge_right, monotone)
    @assertEqual(answer, recon, tol)

    ! Test negative departure distance with no monotonicity
    monotone = horizontal_monotone_none
    dep_pt = -0.2_r_tran
    answer = 2.64_r_tran

    call subgrid_quadratic_recon(recon, dep_pt, rho, edge_left, edge_right, monotone)
    @assertEqual(answer, recon, tol)

    ! Test negative departure distance with positive monotonicity
    monotone = horizontal_monotone_positive
    dep_pt = -0.2_r_tran
    answer = 2.64_r_tran

    call subgrid_quadratic_recon(recon, dep_pt, rho, edge_left, edge_right, monotone)
    @assertEqual(answer, recon, tol)

  end subroutine subgrid_quadratic_recon_test

  !------------------------------------------------------------------

  @test
  subroutine bound_field_test()
    use pFUnit_Mod
    use, intrinsic :: iso_fortran_env,  only: real64
    use subgrid_horizontal_support_mod, only: bound_field

    implicit none

    real(kind=r_tran)   :: field, field_one, field_two
    real(kind=r_tran)   :: answer, tol

    ! Set tolerance
    if ( r_tran == real64 ) then
      tol = 1.0e-12_r_tran
    else
      tol = 1.0e-6_r_tran
    end if

    ! Set field bounds
    field_one = 0.5_r_tran
    field_two = 2.0_r_tran

    ! First check that a field within the bounds is not changed
    field     = 1.0_r_tran
    answer    = 1.0_r_tran
    call bound_field(field, field_one, field_two)
    @assertEqual(answer, field, tol)

    ! Second check that a field is bounded below
    field     = 0.25_r_tran
    answer    = 0.5_r_tran
    call bound_field(field, field_one, field_two)
    @assertEqual(answer, field, tol)

    ! Third check that a field is bounded above
    field     = 3.8_r_tran
    answer    = 2.0_r_tran
    call bound_field(field, field_one, field_two)
    @assertEqual(answer, field, tol)

  end subroutine bound_field_test

  !------------------------------------------------------------------

  @test
  subroutine horizontal_nirvana_case_test()
    use pFUnit_Mod
    use, intrinsic :: iso_fortran_env,  only: real64
    use subgrid_horizontal_support_mod, only: horizontal_nirvana_case

    implicit none

    real(kind=r_tran)   :: tol
    integer(kind=i_def) :: i
    integer(kind=i_def) :: ipanel(3), spt_case, answer

    ! Set tolerance
    if ( r_tran == real64 ) then
      tol = 1.0e-12_r_tran
    else
      tol = 1.0e-6_r_tran
    end if

    ! If panel ID is the same we get case 1
    ipanel(1:3) = 1_i_def
    answer      = 1_i_def
    call horizontal_nirvana_case(ipanel,spt_case)
    @assertEqual(real(answer,r_tran), real(spt_case,r_tran), tol)

    ! If point 3 is on a different panel we get case 2
    ipanel(1:2) = 1_i_def
    ipanel(3)   = 2_i_def
    answer      = 2_i_def
    call horizontal_nirvana_case(ipanel,spt_case)
    @assertEqual(real(answer,r_tran), real(spt_case,r_tran), tol)

    ! If point 1 is on a different panel we get case 3
    ipanel(1)   = 6_i_def
    ipanel(2:3) = 4_i_def
    answer = 3_i_def
    call horizontal_nirvana_case(ipanel,spt_case)
    @assertEqual(real(answer,r_tran), real(spt_case,r_tran), tol)

  end subroutine horizontal_nirvana_case_test

!------------------------------------------------------------------

  @test
  subroutine horizontal_ppm_case_test()
    use pFUnit_Mod
    use, intrinsic :: iso_fortran_env,  only: real64
    use subgrid_horizontal_support_mod, only: horizontal_ppm_case

    implicit none

    real(kind=r_tran)   :: tol
    integer(kind=i_def) :: i
    integer(kind=i_def) :: ipanel(5), spt_case, answer

    ! Set tolerance
    if ( r_tran == real64 ) then
      tol = 1.0e-12_r_tran
    else
      tol = 1.0e-6_r_tran
    end if

    ! If panel ID is the same we get case 1
    ipanel(1:5) = 1_i_def
    answer      = 1_i_def
    call horizontal_ppm_case(ipanel,spt_case)
    @assertEqual(real(answer,r_tran), real(spt_case,r_tran), tol)

    ! If point 5 is on a different panel we get case 2
    ipanel(1:4) = 1_i_def
    ipanel(5)   = 4_i_def
    answer      = 2_i_def
    call horizontal_ppm_case(ipanel,spt_case)
    @assertEqual(real(answer,r_tran), real(spt_case,r_tran), tol)

    ! If points 4 and 5 are on a different panel we get case 3
    ipanel(1:3) = 2_i_def
    ipanel(4:5) = 5_i_def
    answer      = 3_i_def
    call horizontal_ppm_case(ipanel,spt_case)
    @assertEqual(real(answer,r_tran), real(spt_case,r_tran), tol)

    ! If point 1 is on a different panel we get case 4
    ipanel(1)   = 2_i_def
    ipanel(2:5) = 1_i_def
    answer      = 4_i_def
    call horizontal_ppm_case(ipanel,spt_case)
    @assertEqual(real(answer,r_tran), real(spt_case,r_tran), tol)

    ! If points 1 and 2 are on a different panel we get case 5
    ipanel(1:2) = 1_i_def
    ipanel(3:5) = 2_i_def
    answer      = 5_i_def
    call horizontal_ppm_case(ipanel,spt_case)
    @assertEqual(real(answer,r_tran), real(spt_case,r_tran), tol)

  end subroutine horizontal_ppm_case_test

!------------------------------------------------------------------

  @test
  subroutine nirvana_special_edge_test()
    use pFUnit_Mod
    use, intrinsic :: iso_fortran_env,  only: real64
    use subgrid_horizontal_support_mod, only: nirvana_special_edge

    implicit none

    real(kind=r_tran)   :: rho(1:5), edge_left, edge_right, tol
    real(kind=r_tran)   :: answer_left, answer_right
    integer(kind=i_def) :: spt_case

    ! Set tolerance
    if ( r_tran == real64 ) then
      tol = 1.0e-12_r_tran
    else
      tol = 1.0e-6_r_tran
    end if

    ! Set up a non-linear function
    rho(1) = 4.0_r_tran
    rho(2) = 1.0_r_tran
    rho(3) = 4.0_r_tran
    rho(4) = 10.0_r_tran
    rho(5) = 16.0_r_tran

    ! Test all points on same panel
    spt_case = 1_i_def
    answer_left  = 2.0_r_tran
    answer_right = 6.5_r_tran

    call nirvana_special_edge(rho, spt_case, edge_left, edge_right)
    @assertEqual(answer_left,  edge_left, tol)
    @assertEqual(answer_right, edge_right, tol)

    ! Test shifted left
    spt_case = 2_i_def
    answer_left  = 1.5_r_tran
    answer_right = 7.5_r_tran

    call nirvana_special_edge(rho, spt_case, edge_left, edge_right)
    @assertEqual(answer_left,  edge_left, tol)
    @assertEqual(answer_right, edge_right, tol)

    ! Test shifted right
    spt_case = 3_i_def
    answer_left  = 1.0_r_tran
    answer_right = 7.0_r_tran

    call nirvana_special_edge(rho, spt_case, edge_left, edge_right)
    @assertEqual(answer_left,  edge_left, tol)
    @assertEqual(answer_right, edge_right, tol)

  end subroutine nirvana_special_edge_test

  !------------------------------------------------------------------

  @test
  subroutine linear_special_edge_test()
    use pFUnit_Mod
    use, intrinsic :: iso_fortran_env,  only: real64
    use subgrid_horizontal_support_mod, only: linear_special_edge

    implicit none

    real(kind=r_tran)   :: rho(1:3), edge_left, edge_right, tol
    real(kind=r_tran)   :: answer_left, answer_right
    integer(kind=i_def) :: spt_case

    ! Set tolerance
    if ( r_tran == real64 ) then
      tol = 1.0e-12_r_tran
    else
      tol = 1.0e-6_r_tran
    end if

    ! Set up a non-linear function
    rho(1) = 1.0_r_tran
    rho(2) = 4.0_r_tran
    rho(3) = 10.0_r_tran

    ! Test all points on same panel
    spt_case = 1_i_def
    answer_left  = 2.0_r_tran
    answer_right = 6.5_r_tran

    call linear_special_edge(rho, spt_case, edge_left, edge_right)
    @assertEqual(answer_left,  edge_left, tol)
    @assertEqual(answer_right, edge_right, tol)

    ! Test shifted left
    spt_case = 2_i_def
    answer_left  = 2.5_r_tran
    answer_right = 5.5_r_tran

    call linear_special_edge(rho, spt_case, edge_left, edge_right)
    @assertEqual(answer_left,  edge_left, tol)
    @assertEqual(answer_right, edge_right, tol)

    ! Test shifted right
    spt_case = 3_i_def
    answer_left  = 1.0_r_tran
    answer_right = 7.0_r_tran

    call linear_special_edge(rho, spt_case, edge_left, edge_right)
    @assertEqual(answer_left,  edge_left, tol)
    @assertEqual(answer_right, edge_right, tol)

  end subroutine linear_special_edge_test

  !------------------------------------------------------------------

  @test
  subroutine fourth_order_special_edge_test()
    use pFUnit_Mod
    use, intrinsic :: iso_fortran_env,  only: real64
    use subgrid_horizontal_support_mod, only: fourth_order_special_edge

    implicit none

    real(kind=r_tran)   :: rho(1:7), edge_left, edge_right, tol
    real(kind=r_tran)   :: answer_left, answer_right
    integer(kind=i_def) :: spt_case

    ! Set tolerance
    if ( r_tran == real64 ) then
      tol = 1.0e-12_r_tran
    else
      tol = 1.0e-6_r_tran
    end if

    ! Set up a non-linear function
    rho(1) = 2.0_r_tran
    rho(2) = 3.0_r_tran
    rho(3) = 2.0_r_tran
    rho(4) = 1.0_r_tran
    rho(5) = 2.0_r_tran
    rho(6) = 3.0_r_tran
    rho(7) = 4.0_r_tran

    ! Test all points on same panel
    spt_case = 1_i_def
    answer_left  = 4.0_r_tran/3.0_r_tran
    answer_right = 4.0_r_tran/3.0_r_tran

    call fourth_order_special_edge(rho, spt_case, edge_left, edge_right)
    @assertEqual(answer_left,  edge_left, tol)
    @assertEqual(answer_right, edge_right, tol)

    ! Shift left by 1
    spt_case = 2_i_def
    answer_left  = 4.0_r_tran/3.0_r_tran
    answer_right = 1.0_r_tran

    call fourth_order_special_edge(rho, spt_case, edge_left, edge_right)
    @assertEqual(answer_left,  edge_left, tol)
    @assertEqual(answer_right, edge_right, tol)

    ! Shift left by 2
    spt_case = 3_i_def
    answer_left  = 4.0_r_tran/3.0_r_tran
    answer_right = 1.0_r_tran

    call fourth_order_special_edge(rho, spt_case, edge_left, edge_right)
    @assertEqual(answer_left,  edge_left, tol)
    @assertEqual(answer_right, edge_right, tol)

    ! Shift right by 1
    spt_case = 4_i_def
    answer_left  = 1.0_r_tran
    answer_right = 4.0_r_tran/3.0_r_tran

    call fourth_order_special_edge(rho, spt_case, edge_left, edge_right)
    @assertEqual(answer_left,  edge_left, tol)
    @assertEqual(answer_right, edge_right, tol)

    ! Shift right by 2
    spt_case = 5_i_def
    answer_left  = 0.5_r_tran
    answer_right = 1.5_r_tran

    call fourth_order_special_edge(rho, spt_case, edge_left, edge_right)
    @assertEqual(answer_left,  edge_left, tol)
    @assertEqual(answer_right, edge_right, tol)

  end subroutine fourth_order_special_edge_test

  !------------------------------------------------------------------

  @test
  subroutine fourth_nirvana_special_edge_test()
    use pFUnit_Mod
    use, intrinsic :: iso_fortran_env,  only: real64
    use subgrid_horizontal_support_mod, only: fourth_nirvana_special_edge

    implicit none

    real(kind=r_tran)   :: rho(1:5), edge_left, edge_right, tol
    real(kind=r_tran)   :: answer_left, answer_right
    integer(kind=i_def) :: spt_case

    ! Set tolerance
    if ( r_tran == real64 ) then
      tol = 1.0e-12_r_tran
    else
      tol = 1.0e-6_r_tran
    end if

    ! Set up a non-linear function
    rho(1) = 4.0_r_tran
    rho(2) = 1.0_r_tran
    rho(3) = 4.0_r_tran
    rho(4) = 10.0_r_tran
    rho(5) = 16.0_r_tran

    ! Test all points on same panel
    spt_case = 1_i_def
    answer_left  = 1.75_r_tran
    answer_right = 6.75_r_tran

    call fourth_nirvana_special_edge(rho, spt_case, edge_left, edge_right)
    @assertEqual(answer_left,  edge_left, tol)
    @assertEqual(answer_right, edge_right, tol)

    ! Do Nirvana edge
    spt_case = 2_i_def
    answer_left  = 2.0_r_tran
    answer_right = 6.5_r_tran

    call fourth_nirvana_special_edge(rho, spt_case, edge_left, edge_right)
    @assertEqual(answer_left,  edge_left, tol)
    @assertEqual(answer_right, edge_right, tol)

    ! Shift left
    spt_case = 3_i_def
    answer_left  = 1.5_r_tran
    answer_right = 7.5_r_tran

    call fourth_nirvana_special_edge(rho, spt_case, edge_left, edge_right)
    @assertEqual(answer_left,  edge_left, tol)
    @assertEqual(answer_right, edge_right, tol)

    ! Shift right
    spt_case = 5_i_def
    answer_left  = 1.0_r_tran
    answer_right = 7.0_r_tran

    call fourth_nirvana_special_edge(rho, spt_case, edge_left, edge_right)
    @assertEqual(answer_left,  edge_left, tol)
    @assertEqual(answer_right, edge_right, tol)

  end subroutine fourth_nirvana_special_edge_test

  !------------------------------------------------------------------

end module subgrid_horizontal_support_mod_test
